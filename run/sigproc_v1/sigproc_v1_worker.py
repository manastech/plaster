"""
This is the Signal Processor that extracts data from images from the fluoro-sequencer microscope.

Nomenclature
    Field
        One position of the X/Y stage
    Channel
        One wavelength of measured light
    Cycle
        One chemical cycle (Pre, Mock or Edman)
    Anomaly
        An area of an image that has a problem (dust, etc)
    Raw image
        Unmodified images
    Balance image
        A raw image scaled to compensate for uneven illumination
    Aligned field stack
        The stage is not perfect and may not return to exactly the same position
        each cycle, a computational alignment correction finds the optimal X/Y translation.
    Border
        The extra dead space that is added to an aligned field stack to ensure
        that all images are visible.
    Composite image
        When 1+ of the channels/cycles for a field are stacked
    Background removed image
        When an image has the background subtracted. This may
        result in negative values so be careful when displaying.
    Fiducial images
        Any image (may just be a transform of raw data) that is intended only
        to enhance the alignment algorithm.
    Peak
        A spot found that, presumably, is generated by a single molecule.
    Radmat (aka "Radiometry Matrix")
        A matrix such that each row is a peak and each column is a measurement of brightness
        (using area-under-the-curve of the peak) for each channel/cycle.
        Sometimes stored flatten (n_cycles * n_channel)
    cy_ims
        A set of images through all cycles for one field/channel.
    chcy_ims
        A set of images for all channel/cycles for one field.
    roi
        A Region Of Interest
"""

import numpy as np
import scipy
import cv2
from scipy.stats import norm
import math
import pandas as pd
from scipy import ndimage
from plumbum import local
from munch import Munch
from plaster.tools.utils.utils import safe_list_get, is_power_of_2
from plaster.tools.utils import utils
from plaster.tools.zap import zap
from plaster.tools.image import imops
from plaster.tools.image.coord import XY, YX, WH, HW, ROI, Rect
from plaster.tools.log.log import debug, prof
from plaster.tools.schema import check
from plaster.run.sigproc_v1.sigproc_v1_result import SigprocV1Result


def _flatten(s):
    return np.reshape(s, (s.shape[0], s.shape[1] * s.shape[2]))


def _quality(im):
    """
    Measure the quality of an image by spatial low-pass filter.
    High quality images are one where there is very little low-frequency
    (but above DC) bands.
    """
    a = np.copy(im)
    a -= np.mean(a)
    power = np.abs(np.fft.fftshift(np.fft.fft2(a)))
    power[power == 0] = 1

    cen = YX(power.shape) / 2
    dim_half = 3
    dim = HW(dim_half * 2 + 1, dim_half * 2 + 1)
    roi = ROI(cen, dim, center=True)
    im = power[roi]

    eigen = imops.eigen_moments(im)
    score = power.sum() / np.sqrt(eigen.sum())
    return score


def _find_anomalies(cy_ims, iqr_bounds):
    """
    Given a cy stack of images for a field, find the anomalies.

    Arguments:
        cy_ims: array (n_cycles, height, width)
        iqr_bounds: The inter-quartile-range to use on the distribution to
            things outside of the normal range.

    Returns:
        List of bad rects for each cycle (List[n_cycles] of lists)
    """
    import skimage  # Defer slow imports
    import skimage.transform  # Defer slow imports
    from scipy.stats import iqr  # Defer slow imports

    def slice_im_into_squares(im, sub_dim):
        # Crazy numpy kung-foo. By reshaping the image into a four-dimensional
        # array I can then use the np.mean on the inner dimensions.
        r, c = im.shape
        assert r == c and r % sub_dim == 0

        im = im.reshape(r // sub_dim, sub_dim, r // sub_dim, sub_dim)

        # At this point, im is now 4-dimensional like: 256, 2, 256, 2
        # But we want the 2, 2 next to each other for simplicity so swap the inner axes

        im = im.swapaxes(1, 2)  # Now its shape is: 256, 256, 2, 2.
        return im

    def dens_squares(frame, subdim):
        assert frame.ndim == 2
        squares = slice_im_into_squares(frame, subdim)

        # squares is like: 256, 256, 2, 2. So we need the mean of the last two axes
        return np.mean(squares, axis=(2, 3))

    assert cy_ims.ndim == 3 and cy_ims.shape[1] == cy_ims.shape[2]

    subdim = 4
    n_cycles = cy_ims.shape[0]

    dens_per_cycle = np.array(
        [dens_squares(cy_ims[cy], subdim) for cy in range(n_cycles)]
    )

    # Use IQR to set the threshold of what will be considered an anomaly across all cycles
    den_threshold = np.median(dens_per_cycle) + scipy.stats.iqr(
        dens_per_cycle, rng=(100 - iqr_bounds, iqr_bounds)
    )

    # FIND the bad rects for each cycle
    bad_rects_by_cycle = []
    bad_by_cycle = []
    mask_by_cycle = []
    for cy in range(n_cycles):
        bad_rects = []
        im = cy_ims[cy]
        dens = dens_per_cycle[cy]

        bad_mask = np.zeros_like(dens)
        bad_mask[dens > den_threshold] = 1

        # EXPAND the bad areas by erosion and dilate.
        # Erosion gets rid of the single-pixel hits and dilation expands the bad areas
        kernel = np.ones((3, 3), np.uint8)
        mask = cv2.erode(bad_mask, kernel, iterations=1)
        mask = cv2.dilate(mask, kernel, iterations=3)

        scale = im.shape[0] // mask.shape[0]
        full_size_mask = skimage.transform.rescale(
            mask, scale=scale, multichannel=False, mode="constant", anti_aliasing=False
        ).astype(bool)

        # FIND rect contours of bad areas
        contours, hierarchy = cv2.findContours(
            full_size_mask.astype("uint8"), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE
        )
        for cnt in contours:
            bad_rects += [cv2.boundingRect(cnt)]

        bad_rects_by_cycle += [bad_rects]
        bad_by_cycle += [bad_mask]
        mask_by_cycle += [mask]

    return bad_rects_by_cycle, dens_per_cycle, bad_by_cycle, mask_by_cycle


def _mask_anomalies(cy_ims, bad_rects_by_cycle):
    """
    Given a cycle stack of images and the list of bad rects,
    fill all these rects with background noise so that the aligner
    won't be confused by those anomalies.

    Arguments:
        cy_ims: array (n_cycles, height, width)
        bad_rects_by_cycle: List of bad rects for each cycle

    Returns:
        A copy of cy_ims with the bad rects masked with noise
    """
    assert cy_ims.ndim == 3 and cy_ims.shape[1] == cy_ims.shape[2]

    n_cycles, _, _ = cy_ims.shape

    masked_ims = np.zeros_like(cy_ims)

    for cy in range(n_cycles):
        src_im = cy_ims[cy]
        bad_rects = bad_rects_by_cycle[cy]

        # MAKE a mask_im with 0 inside bad rects, 1 otherwise
        mask_im = np.ones_like(src_im)
        for rect in bad_rects:
            imops.fill(
                mask_im, loc=XY(rect[0], rect[1]), dim=WH(rect[2], rect[3]), val=0
            )

        # FIND the characteristics of a normal distribution that fits the
        # data that is not masked out (that is, we don't want the anomalies
        # in this distribution).  If src_im is entirely masked, mean=std=0.
        # TASK: This could be accelerated by subsampling.
        mean = std = 0
        if np.any(mask_im):
            mean, std = norm.fit(src_im[mask_im > 0])

        bg_noise = norm.rvs(loc=mean, scale=std, size=src_im.shape, random_state=None)
        masked_ims[cy] = np.where(mask_im < 1, bg_noise, src_im)

    return masked_ims


def _roi_from_edges(b, t, l, r):
    return ROI(loc=YX(b, l), dim=HW(t - b, r - l))


def _hat_masks(hat_rad, brim_rad):
    """"
    Returns hat and brim boolean masks. brim_rad is from the center, _not_ in addition to hat_rad
    """
    mea = 2 * brim_rad + 1
    hat = imops.generate_circle_mask(hat_rad, mea)
    brim = imops.generate_circle_mask(brim_rad, mea)
    brim = brim & ~hat
    return hat, brim


def _remove_nans_from_radiometry(signal, noise, localbg):
    assert signal.shape == noise.shape
    flat_sig = _flatten(signal)
    flat_noi = _flatten(noise)
    flat_lbg = _flatten(localbg)

    nan_rows = np.any(
        np.isnan(flat_sig) | np.isnan(flat_noi) | np.isnan(flat_lbg), axis=1
    )
    rows = np.argwhere(nan_rows)

    signal[rows, :, :] = 0.0
    noise[rows, :, :] = 0.0
    localbg[rows, :, :] = 0.0


def _radiometry(im, loc, dim, bg_bias, localbg_mask):
    """
    Arguments:
        im: 2D image (some field, channel, cycle)
        loc: the (y,x) coordinates of the peak
        dim: the integer dimensions of the mask
        bg_bias: the background bias to remove

    Returns:
        signal, noise (or NAN if something goes wrong). Both are always non-negative
        localbg: The median of a surrounding aria

    After a careful analysis considering three types of radiometers the Kernel Method was chosen
    The others considered were:
        * Hat method where the signal is the sum(hat_pixel - brim_median).
            * This is fast but scores poorly compared to Kernel Method.
              And, it can not estimate noise.
        * Fitted method where a 2D Gaussian is fit to the data.
            * This method is very expensive, fails to converge in various edge cases,
              and doesn't score any better than the Kernel Method.
        * Kernel method (chosen) where a center-of-mass calculation is used
          to generate a unit-area Gaussian Kernel which is then used to
          weigh the peak data. Noise can be estimated by squaring that mask and
          then computing residuals.
    """
    assert localbg_mask.shape[0] == dim[0] and localbg_mask.shape[1] == dim[1]
    roi = ROI(loc, dim, center=True)
    nans = (np.nan, np.nan, np.nan)

    # REJECT if too near edges
    if (
        roi[0].start < 0
        or roi[1].start < 0
        or roi[0].stop >= im.shape[0]
        or roi[1].stop >= im.shape[1]
    ):
        return nans

    peak_im = im[roi[0], roi[1]]
    localbg = np.median(peak_im[localbg_mask])

    # CENTER by finding the Center Of Mass (COM)
    positive = np.where(peak_im > 0, peak_im, 0.0)
    if positive.sum() == 0.0:
        # Avoid COM warning from library by testing for all zeros
        return nans

    com = ndimage.measurements.center_of_mass(positive)
    offset_y = com[0] - int(peak_im.shape[0] / 2)
    offset_x = com[1] - int(peak_im.shape[1] / 2)

    if not (-2 <= offset_y <= 2 and -2 <= offset_x <= 2):
        # Data is so poor that the center-of-mass outside of reasonable bounds
        return nans

    # REMOVE the background
    peak_im = (peak_im - bg_bias).clip(min=0)

    kernel = imops.generate_gauss_kernel(1.0, offset_x, offset_y, mea=peak_im.shape[0])
    kernel_squared = kernel * kernel
    kernel_squared_sum = kernel_squared.sum()

    # WEIGH the data with the kernel and then normalize by the kernel_squared_sum to estimate signal
    weighted = kernel * peak_im
    signal = weighted.sum() / kernel_squared_sum

    # COMPUTE the noise by examining the residuals
    residuals = peak_im - signal * kernel
    var_residuals = np.var(residuals)
    noise = np.sqrt(var_residuals / kernel_squared_sum)
    assert noise >= 0.0

    return max(0, signal), noise, localbg


def _step_1_measure_quality(raw_chcy_ims, sigproc_params):
    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim

    quality = np.zeros((n_inchannels, n_cycles))
    for cy in range(n_cycles):
        for ch in range(n_inchannels):
            quality[ch, cy] = _quality(raw_chcy_ims[ch, cy])

    return quality


def _step_2a_mask_anomalies(raw_chcy_ims, sigproc_params):
    """
    Find anomalies and fill them with background noise so that
    they won't fool the aligner.

    Arguments:
        raw_chcy_ims: (n_channel, n_cycles, dim, dim)
        sigproc_params: SigprocParams

    Returns:
        raw_mask_rects: a list of bad rect lists (channel, cycle)
            i.e. for each channel there is a list inside of which is a list per cycle
            inside of which is a list of bad rects
        anomaly_removed_chcy_ims: Copies of the raw_chcy_ims with the bad areas
            filled in with background-like noise so that the aligner won't get confused.
    """

    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim

    anom_iqr_cutoff = sigproc_params.anomaly_iqr_cutoff
    raw_mask_rects = [None] * n_inchannels
    dst_chcy_ims = np.copy(raw_chcy_ims)

    if anom_iqr_cutoff is not None:
        for ch in range(n_inchannels):
            raw_mask_rects[ch], _, _, _ = _find_anomalies(
                raw_chcy_ims[ch, :], anom_iqr_cutoff
            )
            dst_chcy_ims[ch, :] = _mask_anomalies(
                raw_chcy_ims[ch, :], raw_mask_rects[ch]
            )

    return raw_mask_rects, dst_chcy_ims


def _step_2b_find_bg_median(chcy_ims, sigproc_params):
    """
    Computes the median of the image on each channel/cycle

    Returns:
        medians_by_ch_cy: A matrix of median values
    """
    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim

    medians_by_ch_cy = np.zeros((n_inchannels, n_cycles))
    for cy in range(n_cycles):
        for ch in range(n_inchannels):
            medians_by_ch_cy[ch, cy] = np.median(chcy_ims[ch, cy])

    return medians_by_ch_cy


def _step_2c_composite_channels(chcy_ims, medians_by_ch_cy, sigproc_params):
    """
    Merges specified channels for each cycle after background subtraction.

    The channel list is sometimes partial because there are some
    experiments where data was recorded in a channel that is bad.

    Returns:
        composite cy_ims (channels merged) after background subtraction
    """
    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim

    dst_cy_ims = np.zeros((n_cycles, dim, dim))
    for cy in range(n_cycles):
        for inch in range(n_inchannels):
            if inch in sigproc_params.channel_indices_for_alignment:
                imops.accum_inplace(
                    dst_cy_ims[cy],
                    (chcy_ims[inch, cy] - medians_by_ch_cy[inch, cy]).clip(min=0),
                )

    return dst_cy_ims


def _step_2_align(raw_chcy_ims, sigproc_params):
    """
    Each cycle the stage moves, but it is not perfectly accurate when it returns
    to the same field.

    The stage does _not_ move between channels, therefore
    the channels for each field over each cycle can be merged to improve alignment.

    Returns:
        A DataFrame of all the results, most importantly the shift_y, shift_x
            needed to each cycle to align the images.
        ch_merged_cy_ims
    """

    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim

    raw_mask_rects, anomaly_removed_ims = _step_2a_mask_anomalies(
        raw_chcy_ims, sigproc_params
    )

    medians_by_ch_cy = _step_2b_find_bg_median(raw_chcy_ims, sigproc_params)

    ch_merged_cy_ims = _step_2c_composite_channels(
        anomaly_removed_ims, medians_by_ch_cy, sigproc_params
    )

    # GENERATE fiducial_ims
    kernel = imops.generate_gauss_kernel(1.0)
    kernel = kernel - kernel.mean()  # Eliminate DC bias
    fiducial_ims = np.array(
        [imops.convolve(im.clip(min=0), kernel) for im in ch_merged_cy_ims]
    )

    alignment_offsets, alignment_scores = imops.align(fiducial_ims)

    ch_out_to_in = sigproc_params.output_channel_to_input_channel

    field_df = pd.DataFrame(
        [
            dict(
                cycle_i=cy,
                shift_y=off[0],
                shift_x=off[1],
                aln_score=aln_score,
                channel_i=outch,
                bg_median=medians_by_ch_cy[ch_out_to_in(outch), cy],
                n_mask_rects=len(raw_mask_rects[ch_out_to_in(outch)][cy]),
                mask_area=sum(
                    [
                        rect[2] * rect[3]
                        for rect in raw_mask_rects[ch_out_to_in(outch)][cy]
                    ]
                ),
            )
            for outch in range(n_outchannels)
            for cy, off, aln_score in zip(
                range(n_cycles), alignment_offsets, alignment_scores
            )
        ]
    )

    return field_df, ch_merged_cy_ims, raw_mask_rects


def _step_3_composite_aligned_images(
    field_df, ch_merged_cy_ims, raw_chcy_ims, sigproc_params
):
    """
    Generate aligned images and composites
    """
    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim

    # Note offsets are the same for each channel, and we only want one set of
    # offsets because we're aligning channel-merged images.
    offsets = [
        XY(row.shift_x, row.shift_y)
        for row in field_df[field_df.channel_i == 0]
        .set_index("cycle_i")
        .sort_index()[["shift_y", "shift_x"]]
        .itertuples()
    ]
    # Needs to be a list of Coords

    median_by_ch_cy = (
        field_df.set_index(["channel_i", "cycle_i"])
        .sort_index()
        .bg_median.values.reshape((n_outchannels, n_cycles))
    )

    chcy_composite_im, border_size = imops.composite(
        ch_merged_cy_ims,
        offsets,
        start_accum=sigproc_params.peak_find_start,
        limit_accum=sigproc_params.peak_find_n_cycles,
    )

    # GENERATE aligned images in the new coordinate system
    aligned_dim = HW(chcy_composite_im.shape)
    aligned_ims = np.zeros((n_outchannels, n_cycles, aligned_dim.h, aligned_dim.w,))
    aligned_raw_chcy_ims = np.zeros_like(aligned_ims)
    border = YX(border_size, border_size)
    for outch in range(n_outchannels):
        inch = sigproc_params.output_channel_to_input_channel(outch)
        for cy, offset in zip(range(n_cycles), offsets):
            imops.accum_inplace(
                aligned_raw_chcy_ims[outch, cy],
                src=raw_chcy_ims[inch, cy],
                loc=border - offset,
            )
            imops.accum_inplace(
                aligned_ims[outch, cy],
                src=(raw_chcy_ims[inch, cy] - median_by_ch_cy[outch, cy]).clip(min=0),
                loc=border - offset,
            )

    # BLACK out the borders by clipping in only pixels that are in every cycle
    l = border_size - field_df.shift_x.min()
    r = aligned_dim.w - border_size - field_df.shift_x.max()
    b = border_size - field_df.shift_y.min()
    t = aligned_dim.h - border_size - field_df.shift_y.max()
    roi = _roi_from_edges(b, t, l, r)
    aligned_roi_rect = Rect(b, t, l, r)

    aligned_composite_chcy_im = np.zeros(aligned_dim)
    aligned_composite_chcy_im[roi] = chcy_composite_im[roi]
    med = np.median(chcy_composite_im[roi])
    aligned_composite_bg_removed_im = (aligned_composite_chcy_im - med).clip(min=0)

    return (
        border_size,
        aligned_roi_rect,
        aligned_composite_bg_removed_im,
        aligned_raw_chcy_ims,
    )


def _step_4_find_peaks(
    aligned_composite_bg_removed_im,
    aligned_roi_rect,
    raw_mask_rects,
    border_size,
    field_df,
    sigproc_params,
):
    """
    Find peaks on the composite image

    TASK: Remove the mask rect checks and replace with the same masking
    logic that is now implemented in the alignment phase. That is, just remove
    the peaks from the source instead of in post-processing.
    """
    from skimage.feature import peak_local_max  # Defer slow import
    from scipy.stats import iqr

    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim
    assert (
        aligned_composite_bg_removed_im.shape[0]
        == aligned_composite_bg_removed_im.shape[1]
    )
    aligned_dim, _ = aligned_composite_bg_removed_im.shape
    check.array_t(aligned_composite_bg_removed_im, is_square=True)

    hat_rad = sigproc_params.hat_rad
    brim_rad = sigproc_params.hat_rad + 1
    hat_mask, brim_mask = _hat_masks(hat_rad, brim_rad)

    kernel = imops.generate_gauss_kernel(1.0)
    kernel = kernel - kernel.mean()
    _fiducial_im = imops.convolve(aligned_composite_bg_removed_im, kernel)

    # Black out the convolution artifact around the perimeter of the _fiducial_im
    search_roi_rect = Rect(
        aligned_roi_rect.b + brim_rad,
        aligned_roi_rect.t - brim_rad,
        aligned_roi_rect.l + brim_rad,
        aligned_roi_rect.r - brim_rad,
    )
    search_roi = search_roi_rect.roi()
    composite_fiducial_im = np.zeros_like(aligned_composite_bg_removed_im)

    # Use Inter-Quartile Range for some easy filtering
    _iqr = 0
    if sigproc_params.iqr_rng is not None:
        _iqr = iqr(
            _fiducial_im[search_roi],
            rng=(100 - sigproc_params.iqr_rng, sigproc_params.iqr_rng),
        )

    composite_fiducial_im[search_roi] = (_fiducial_im[search_roi] - _iqr).clip(min=0)

    locs = peak_local_max(
        composite_fiducial_im,
        min_distance=hat_rad,
        threshold_abs=sigproc_params.threshold_abs,
    )

    # Emergency exit to prevent memory overflows
    # check.affirm(len(locs) < 7000, f"Too many peaks {len(locs)}")

    shift = field_df.set_index("cycle_i").sort_index()[["shift_y", "shift_x"]].values
    shift_y = shift[:, 0]
    shift_x = shift[:, 1]

    # Discard any peak in any mask_rect
    # ALIGN the mask rects to the composite coordinate system
    aligned_mask_rects = []
    for channel in range(sigproc_params.n_output_channels):
        channel_rects = safe_list_get(raw_mask_rects, channel, [])
        for cycle in range(n_cycles):
            for rect in safe_list_get(channel_rects, cycle, []):
                yx = XY(rect[0], rect[1])
                hw = WH(rect[2], rect[3])
                yx += XY(border_size, border_size) - XY(shift_x[cycle], shift_y[cycle])
                aligned_mask_rects += [(yx[0], yx[1], yx[0] + hw[0], yx[1] + hw[1])]

    aligned_mask_rects = np.array(aligned_mask_rects)
    if aligned_mask_rects.shape[0] > 0:

        # To compare every loc with every mask rect we use the tricky np.fn.outer()
        y_hits = np.greater_equal.outer(locs[:, 0], aligned_mask_rects[:, 0])
        y_hits &= np.less.outer(locs[:, 0], aligned_mask_rects[:, 2])

        x_hits = np.greater_equal.outer(locs[:, 1], aligned_mask_rects[:, 1])
        x_hits &= np.less.outer(locs[:, 1], aligned_mask_rects[:, 3])

        inside_rect = x_hits & y_hits  # inside a rect if x and y are inside the rect
        locs_to_keep = ~np.any(
            inside_rect, axis=1
        )  # Reject if inside of any masked rect
        locs = locs[locs_to_keep]

    circle_im = np.zeros((aligned_dim, aligned_dim))

    center = aligned_dim / 2

    peak_rows = []
    for field_peak_i, loc in enumerate(locs):
        if sigproc_params.radial_filter is not None:
            radius = math.sqrt((loc[0] - center) ** 2 + (loc[1] - center) ** 2)
            radius /= center
            if radius >= sigproc_params.radial_filter:
                continue

        imops.set_with_mask_in_place(circle_im, brim_mask, 1, loc=loc, center=True)

        peak_rows += [
            Munch(
                peak_i=0,
                field_peak_i=field_peak_i,
                aln_y=int(loc[0]),
                aln_x=int(loc[1]),
            )
        ]

    peak_df = pd.DataFrame(peak_rows)

    return peak_df, circle_im, aligned_mask_rects


def _step_5_radiometry(peak_df, field_df, aligned_raw_chcy_ims, sigproc_params):
    """
    Radiometry measures the area under the curve of the PSF
    """

    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim
    n_peaks = len(peak_df)

    hat_rad = sigproc_params.hat_rad
    brim_rad = sigproc_params.hat_rad + 1
    hat_mask, brim_mask = _hat_masks(hat_rad, brim_rad)

    signal_radmat = np.zeros((n_peaks, n_outchannels, n_cycles))
    noise_radmat = np.zeros((n_peaks, n_outchannels, n_cycles))
    localbg_radmat = np.zeros((n_peaks, n_outchannels, n_cycles))

    trace_dim = HW(brim_mask.shape) + HW(4, 4)
    localbg_mask = np.zeros(trace_dim)
    imops.accum_inplace(localbg_mask, brim_mask, loc=trace_dim / 2, center=True)
    localbg_mask = localbg_mask > 0

    medians_by_chcy = (
        field_df.set_index(["channel_i", "cycle_i"]).sort_index().bg_median
    )

    # This triple-nested loop is a potential point of optimization
    # But it is probably dwarfed by the time it takes to do a center-of-mass
    # calculation for each peak on each channel/cycle.
    # Note that I was previously doing the COM calculation only
    # once for a cycle stack but since I don't do sub-pixel
    # alignment on each cycle I think it will be more accurate
    # to re-do the COM calculation on every cycle.
    for peak_i, peak_row in peak_df.iterrows():
        for outch in range(n_outchannels):
            for cycle in range(n_cycles):
                signal, noise, localbg = _radiometry(
                    aligned_raw_chcy_ims[outch, cycle],
                    XY(peak_row.aln_x, peak_row.aln_y),
                    trace_dim,
                    medians_by_chcy[outch, cycle],
                    localbg_mask,
                )
                signal_radmat[peak_i, outch, cycle] = signal
                noise_radmat[peak_i, outch, cycle] = noise
                localbg_radmat[peak_i, outch, cycle] = localbg

    # Any peak that has a NAN in it anywhere, zero it out
    _remove_nans_from_radiometry(signal_radmat, noise_radmat, localbg_radmat)

    return signal_radmat, noise_radmat, localbg_radmat


def _do_field(field_i, ims_import_result, sigproc_result, sigproc_params):
    """
    Steps:
        1. Measure quality
        2. Align the images (corrects for stage imprecision)
            2a. Mask anomalies
            2b. Find background median
            2c. Composite channels with background subtracted
        3. Composite the aligned images
        4. Peak find in the aligned images
        5. Measure radiometry (AUC of peaks)
    """

    raw_chcy_ims = ims_import_result.field_chcy_ims(field_i)
    _, n_cycles, h, w = raw_chcy_ims.shape
    assert is_power_of_2(w) and w == h

    quality = _step_1_measure_quality(raw_chcy_ims, sigproc_params)

    field_df, ch_merged_cy_ims, raw_mask_rects = _step_2_align(
        raw_chcy_ims, sigproc_params
    )

    (
        border_size,
        aligned_roi_rect,
        aligned_composite_bg_removed_im,
        aligned_raw_chcy_ims,
    ) = _step_3_composite_aligned_images(
        field_df, ch_merged_cy_ims, raw_chcy_ims, sigproc_params
    )

    peak_df, circle_im, aligned_mask_rects = _step_4_find_peaks(
        aligned_composite_bg_removed_im,
        aligned_roi_rect,
        raw_mask_rects,
        border_size,
        field_df,
        sigproc_params,
    )

    signal_radmat, noise_radmat, localbg_radmat = _step_5_radiometry(
        peak_df, field_df, aligned_raw_chcy_ims, sigproc_params
    )

    field_df["field_i"] = field_i
    peak_df["field_i"] = field_i

    field_df["border_size"] = border_size
    field_df["aligned_roi_rect_l"] = aligned_roi_rect.l
    field_df["aligned_roi_rect_r"] = aligned_roi_rect.r
    field_df["aligned_roi_rect_b"] = aligned_roi_rect.b
    field_df["aligned_roi_rect_t"] = aligned_roi_rect.t

    n_outchannels, n_inchannels, n_cycles, dim = sigproc_params.channels_cycles_dim

    quality_df = pd.DataFrame(
        [
            (
                outchannel_i,
                cycle_i,
                quality[sigproc_params.output_channel_to_input_channel(outchannel_i)][
                    cycle_i
                ],
            )
            for outchannel_i in range(n_outchannels)
            for cycle_i in range(n_cycles)
        ],
        columns=["channel_i", "cycle_i", "quality"],
    )

    ch_cy_index = ["channel_i", "cycle_i"]
    field_df = (
        field_df.set_index(ch_cy_index)
        .join(quality_df.set_index(ch_cy_index), how="outer")
        .reset_index()
    )

    # Merge the metadata from ims_import into the field_df
    try:
        field_df = (
            field_df.set_index(["field_i", "cycle_i"]).join(
                ims_import_result.metadata().set_index(["field_i", "cycle_i"]),
                how="left",
            )
        ).reset_index()
    except Exception as e:
        # This is normal when in tif mode
        pass
        # debug(e)
        # debug(ims_import_result.metadata().reset_index().columns)
        # debug(field_df.reset_index().columns)

    sigproc_result.save_field(
        field_i=field_i,
        signal_radmat=signal_radmat,
        noise_radmat=noise_radmat,
        localbg_radmat=localbg_radmat,
        field_df=field_df,
        peak_df=peak_df,
        raw_mask_rects=raw_mask_rects,
        aligned_mask_rects=aligned_mask_rects,
        _raw_chcy_ims=raw_chcy_ims,
        _aligned_composite_bg_removed_im=aligned_composite_bg_removed_im,
    )

    n_channels = signal_radmat.shape[1]
    return n_channels


def sigproc(sigproc_params, ims_import_result, progress=None):
    # CACHE n_channel, n_cycles, dim into sigproc_params by loading one field
    ims = ims_import_result.field_chcy_ims(field_i=0)
    n_inchannels, n_cycles, h, w = ims.shape
    assert h == w
    n_outchannels = sigproc_params.n_output_channels
    sigproc_params._outchannels_inchannels_cycles_dim = (
        n_outchannels,
        n_inchannels,
        n_cycles,
        h,
    )

    if not sigproc_params.channel_indices_for_alignment:
        sigproc_params.channel_indices_for_alignment = list(range(n_inchannels))

    sigproc_result = SigprocV1Result(
        params=sigproc_params,
        n_input_channels=n_inchannels,
        n_channels=n_outchannels,
        n_cycles=n_cycles,
    )

    n_fields = ims_import_result.n_fields
    n_fields_limit = sigproc_params.n_fields_limit
    if n_fields_limit is not None and n_fields_limit < n_fields:
        n_fields = n_fields_limit

    # TASK: I think this would be nicer with the parallel array map
    results = zap.work_orders(
        [
            Munch(
                fn=_do_field,
                field_i=field_i,
                sigproc_params=sigproc_params,
                ims_import_result=ims_import_result,
                sigproc_result=sigproc_result,
            )
            for field_i in range(n_fields)
        ],
        _process_mode=True,
        _trap_exceptions=False,
        _progress=progress,
    )

    # SET the result n_channels (possibly different from input n_channels)
    n_inchannels = np.array(results)
    assert np.all(n_inchannels == n_inchannels[0])
    sigproc_result.n_channels = int(n_inchannels[0])

    return sigproc_result
